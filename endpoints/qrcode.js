const fs = require("fs");
const path = require("path");
const wppconnect = require("@wppconnect-team/wppconnect");
const { acessarServidor } = require("../utils/puppeteer");

const sessions = new Map(); // inst√¢ncias por sess√£o
const locks = new Set(); // evita execu√ß√µes concorrentes

function limparSessao(nome, client) {
  try {
    if (sessions.has(nome)) sessions.delete(nome);
    if (locks.has(nome)) locks.delete(nome);

    const qrcodePath = path.join(__dirname, `../qrcodes/${nome}.png`);
    if (fs.existsSync(qrcodePath)) fs.unlinkSync(qrcodePath);

    if (client) {
      client.close();
      console.log(`[${nome}] üî¥ Cliente WppConnect fechado e sess√£o limpa`);
    }
  } catch (err) {
    console.error(`[${nome}] ‚ö† Erro ao limpar sess√£o: ${err.message}`);
  }
}

module.exports = async (req, res) => {
  const { nome } = req.params;

  if (!nome) return res.status(400).json({ success: false, error: "Nome da sess√£o √© obrigat√≥rio" });
  if (locks.has(nome)) return res.status(429).json({ success: false, error: "J√° existe um processo em andamento para esta sess√£o" });

  try {
    const respostaListar = await acessarServidor("listar_sessoes.php");
    const lista = Array.isArray(respostaListar.sessoes) ? respostaListar.sessoes : [];
    const existe = lista.find((s) => s.nome === nome);

    if (!existe) return res.status(404).json({ success: false, error: "Sess√£o n√£o existe no servidor" });

    locks.add(nome);
    let client = sessions.get(nome);

    // Se j√° existe inst√¢ncia
    if (client) {
      const status = await client.getConnectionState();
      console.log(`[${nome}] üîπ Status atual:`, status);

      if (status === "CONNECTED") {
        limparSessao(nome, client);
        return res.json({ success: true, message: "Sess√£o j√° conectada" });
      }
    }

    console.log(`[${nome}] üîπ Criando nova inst√¢ncia...`);

    // Promise para esperar QR code ser gerado
    const qrPromise = new Promise((resolve, reject) => {
      wppconnect.create({
        session: nome,
        puppeteerOptions: { headless: true, args: ["--no-sandbox", "--disable-setuid-sandbox"] },
        catchQR: (base64Qr) => {
          try {
            const qrcodePath = path.join(__dirname, `../qrcodes/${nome}.png`);
            fs.writeFileSync(qrcodePath, base64Qr.split(",")[1], "base64");
            console.log(`[${nome}] üîπ QRCode gerado e salvo em ${qrcodePath}`);
            resolve(qrcodePath); // Resolve a Promise aqui
          } catch (err) {
            reject(err);
          }
        },
        statusFind: async (statusSession) => {
          console.log(`[${nome}] üîπ Status atualizado: ${statusSession}`);
          if (statusSession === "CONNECTED") {
            try {
              const tokens = await client.getSessionTokenBrowser();
              console.log(`[${nome}] ‚úÖ Sess√£o conectada! Tokens:`, tokens);
              const dados = JSON.stringify({ conectado: true, tokens });
              await acessarServidor("atualizar_sessao.php", { data: { nome, dados } });
              limparSessao(nome, client);
            } catch (err) {
              console.error(`[${nome}] ‚ùå Erro ao atualizar sess√£o conectada:`, err.message);
              limparSessao(nome, client);
            }
          }
        },
      }).then((c) => (client = c))
        .catch((err) => reject(err));
    });

    // Aguarda QR code ser gerado
    const qrcodePath = await qrPromise;

    sessions.set(nome, client);
    locks.delete(nome);

    return res.json({
      success: true,
      message: "QR code gerado e dispon√≠vel",
      qrcode: `/qrcode/${nome}.png`,
    });

  } catch (err) {
    console.error(`[${new Date().toISOString()}] ‚ùå Erro em qrcode.js:`, err.message);
    limparSessao(nome, sessions.get(nome));
    return res.status(500).json({ success: false, error: err.message });
  }
};
